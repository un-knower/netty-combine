# netty4.x 超大文件传输，基于基于http

【实现原理：】

- 1.文件分片传输
- 2.MD5校验服务器文件是否存在
- 3.断点续传
- 4.上传权限校验等功能。

为了实现上面四点，做下实现的思路：

1.文件的分片上传主要用到了RandomAccessFile类，这个类支持读取文件的起始地设置，以及读取字节长度等；
由这个类我们就可以把 文件分成n分（n取决于你每个包想设置多大），每一份上传成功后，服务端开始写到服务
文件里面，然后返回客户端下一个包的文件读取 开始位置以此类推，一直到文件读取完成，服务端返回客户端下
载文件的路径（每上传成功一个包，会返回客户端上传的进度百分比）。 

2.MD5校验，主要是客户端读取文件内容然后把内容生产一个MD5，在上传文件的时候把MD5值也附加在里面。服务
端收到后会先验证MD5值在 服务端是否已经存在，存在则直接返回文件下载地址，并标记上传进度为 100% 

3.断点续传也是基于MD5来判断，服务端发现客户端上传的文件服务端存在，但是这个时候比较客户端文件总长度和
服务端已经存在文件的总长度 不一致，这个时候如果客户端的文件长度大于服务端则认为文件需要续传，返回客户
端现在服务端的文件写入到的位置，让客户端继续接着位置开始 

4.上传权限主要是用来防止客户端恶意上传文件，因为本服务需要对外，不能让没有权限的人知道地址和端口就可以
随意上传。netty支持hander的有序 拦截处理，所以我在这里是把权限验证放第一个hander，客户端连接支持必须
发一个权限验证包，比如把登录后的token传入到服务端，服务端进行验证 token有效性，返回客户端是否验证成功，
并把当前连接加入已验证通过列表。下次上传的包验证通过后直接进入下一个hander处理即可 

在实现功能的时候需要注意以下：
1.传输过程是否支持夸平台（因为服务端对应的客户端有很多如php、java、object-c、.net等）
2.传输内容的编解码
3.粘包、拆包（netty默认支持，这里就不考虑了啊）


本文实现过程中，传输的内容采用的json格式，最开始之间传输用java的序列化来实现的，发现如果客户端是别的语
言就无法使用了，所以就采用了json格式。 当然我建议大家使用Google的 Protocol Buffers 或者 facebook的
Thrift，他们的性能开销是json的1/4不到，大小是json的1/4不到。使用thrift可以参考开 源项目nifty，这个
项目也是Facebook开源出来的。